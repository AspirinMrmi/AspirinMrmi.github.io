<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
      
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>
      前端面试叨逼叨 |  Aspirin&#39;s Blog
    </title>
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">  <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">  <script src="/js/pace.min.js"></script>
  </head>
</html>


<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-前端面试叨逼叨" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  前端面试叨逼叨
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/前端面试叨逼叨/" class="article-date">
  <time datetime="2019-12-22T03:36:47.000Z" itemprop="datePublished">2019-12-22</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/面试圣经/">面试圣经</a>
  </div>

    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <blockquote>
<p>三分天注定，七分靠打拼</p>
</blockquote>
<p><img src="https://i.loli.net/2019/12/22/af2Lh9iDwXMgjWd.jpg" alt></p>
<a id="more"></a>
<blockquote>
<h3 id="JS事件循环你是如何理解的？"><a href="#JS事件循环你是如何理解的？" class="headerlink" title="JS事件循环你是如何理解的？"></a>JS事件循环你是如何理解的？</h3></blockquote>
<p>如果你真的不是科班出身，面对这样的问题，真的是无法去解释，所以我们看图来理解一下这个让人面试屡屡头大的东西：</p>
<p><img src="http://q2nr42tde.bkt.clouddn.com/15fdd88994142347" alt="pic"></p>
<p>我们的程序分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>解读一下导图里的信息：</p>
<ul>
<li>同步任务和异步任务分别进入不同的执行“场所”，同步任务进入主线程，异步任务进入Event Table并注册函数；</li>
<li>当指定的事情完成之后，Event Table会将这个函数移入Event Queue；</li>
<li>主线程内的任务执行完毕，栈为空的时候，会去读取Event Queue中的函数，进入主线程继续执行；</li>
<li>上述过程不断重复，就是所说的事件循环（Event Loop）；</li>
</ul>
<p>语言还是晦涩，通过代码来看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送成功!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>同步任务 <em>console.log(‘代码执行结束’)</em>进入主线程，异步任务ajax请求进入Event Table并注册函数<em>succes</em>；</li>
<li><em>ajax</em>事件完成后，Event Table会将success函数移入Event Queue；</li>
<li>主线程内的任务<em>console.log(‘代码执行结束’)</em>执行完毕，栈为空，主线程从Event Queue中读取<em>success</em>，<em>success</em>进入主线程继续执行；</li>
</ul>
<blockquote>
<h3 id="setTimeout的真正意义是什么？"><a href="#setTimeout的真正意义是什么？" class="headerlink" title="setTimeout的真正意义是什么？"></a>setTimeout的真正意义是什么？</h3></blockquote>
<p>我们通常会理解为：经过指定时间后执行回调程序。</p>
<p>然而</p>
<p>真相是这样的：</p>
<p>经过指定时间后，把要执行的任务加入到Event Queue中，因为JS单线程任务都是一个一个去执行的，如果前面的任务需要执行的时间太久，那么我们指定的需要在setTimeout中执行的任务就会处于一个排号的状态，导致真正的延迟时间不一定是我们当初定义的延迟时间。</p>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line">sleep(<span class="number">100000</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>setTimeout(fn, 0)是个啥？</strong></p>
</blockquote>
<p>意思是说fn立刻执行么？</p>
<p>答案肯定是No！</p>
<p>其真正的含义是：</p>
<p>指定的某个任务（fn）在主线程最早可得的空闲时间执行，即我们不用等多少秒了，就是在主线程执行栈内的所有同步任务执行完毕后，立即执行该任务。</p>
<p>此处的立即需要注意一下：即便主线程为空，0ms实际上也是达不到的。根据HTML的标准，最低是4ms。</p>
<p>因为只要是在setTimeout里面去执行的任务都是属于异步任务，而异步任务只有在主线程栈为空的时候才会去Event Queue去读取异步任务再去执行。</p>
<blockquote>
<h3 id="setInterval又是个什么鬼玩意儿？"><a href="#setInterval又是个什么鬼玩意儿？" class="headerlink" title="setInterval又是个什么鬼玩意儿？"></a>setInterval又是个什么鬼玩意儿？</h3></blockquote>
<p>我之前的理解是setInterval(fn, ms)就是经过多长时间以后去再次执行fn，循环反复……</p>
<p>通过上面我们对setTimeout的认识，其实这样的理解是片面且错误的。</p>
<p>真相是这样的：</p>
<p>setInterval会每隔指定的时间将注册的函数置入Event Queue，所以不是每过ms执行一次fn，而是每过ms会有fn进入Event  Queue，如果回调函数fn的执行时间超过了延迟时间ms，那么将看不出有时间间隔。</p>
<blockquote>
<h3 id="那我们聊聊宏任务和微任务吧？"><a href="#那我们聊聊宏任务和微任务吧？" class="headerlink" title="那我们聊聊宏任务和微任务吧？"></a>那我们聊聊宏任务和微任务吧？</h3></blockquote>
<p>从广义的角度去分类，我们把任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>从更加精细 的角度去分类的话：</p>
<ul>
<li>宏任务（macro-task）：整体代码的script、setTimeout、setInterval</li>
<li>微任务（micro-task）：Promise、process.nextTick</li>
</ul>
<p>针对于更加精细的划分，不同的任务类型会进入不同的Event Queue。</p>
<p><strong>事件循环的顺序决定了Js的执行顺序</strong></p>
<p>我们先照例用生涩的文字来描述这个顺序，然后记得看完图例以及代码例子后回来看这个顺序，相信都会豁然开朗：</p>
<ul>
<li>进入整体代码后，开始第一次循环；</li>
<li>执行所有微任务；</li>
<li>然后再执行宏任务，找到该宏任务其中一个任务队列执行完毕，再执行所有的微任务；</li>
</ul>
<p>事件循环、宏任务、微任务的关系如下图所示：</p>
<p><img src="http://q2nr42tde.bkt.clouddn.com/15fdcea13361a1ec" alt="pic"></p>
<p>再来看一段更加冗长复杂在面试中经常遇到的代码，我们来分析其执行的顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>第一轮事件循环：</p>
<ul>
<li>整体代码作为一个宏任务进入主线程，遇到<em>console.log(‘1’)</em>,输出1；</li>
<li>遇到<em>setTimeout</em>，其回调函数被分发到宏任务Event Queue中，我们暂且记该任务为setTimeout1；</li>
<li>遇到<em>process.nextTick()</em>，其回调函数被分发到微任务Event Queue中，我们暂且记该任务为process1；</li>
<li>遇到<em>promise</em>，new Promise直接执行，输出7；then里面的回调函数被分发到微任务Event Queue中，我们暂且记该任务为then1；</li>
<li>再次遇到<em>setTimeout</em>，其回调函数被分发到宏任务Event Queue中，我们暂且记该任务为setTimeout2；</li>
</ul>
<p>所以，第一轮事件循环下来我们可以对Event Queue做以下归类：</p>
<table>
<thead>
<tr>
<th>宏任务</th>
<th>微任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody>
</table>
<ul>
<li>此时已经输出了1和7；</li>
<li>发现有可执行的微任务，所以执行process1和then1，分别输出6和8；</li>
</ul>
<p>OK，到了这里第一轮事件循环正式结束，输出结果为1、7、6、8。</p>
<p>第二轮事件循环从宏任务setTimeout1开始：</p>
<ul>
<li>首先输出2；</li>
<li>遇到<em>process.nextTick()</em>， 其回调函数被分发到微任务Event Queue中，我们暂且记该任务为process2；</li>
<li>遇到<em>promise</em>，new Promise直接执行输出4，then的回调函数被分发到微任务Event Queue中，我们暂且记该任务为then2；</li>
</ul>
<p>所以，第二轮事件循环下来我们可以对Event Queue做以下归类：</p>
<table>
<thead>
<tr>
<th>宏任务</th>
<th>微任务</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>process2</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then2</td>
</tr>
</tbody>
</table>
<ul>
<li>此时已经输出了2和4；</li>
<li>发现有可执行的微任务，所以执行process2和then2，分别输出3和5；</li>
</ul>
<p>OK，到了这里第二轮事件循环正式结束，输出结果为2、4、3、5。</p>
<p>第三轮事件循环从宏任务setTimeout2开始：</p>
<ul>
<li>首先输出9；</li>
<li>遇到<em>process</em>，其回调函数被分发到微任务Event Queue中，我们暂且记该任务为process3；</li>
<li>遇到<em>promise</em>，new Promise直接执行输出11，then的回调函数被分发到微任务Event Queue中，我们暂且记该任务为then3；</li>
</ul>
<p>所以，第三轮事件循环下来我们可以对Event Queue做以下归类：</p>
<table>
<thead>
<tr>
<th>宏任务</th>
<th>微任务</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody>
</table>
<ul>
<li>此时已经输出了9和11；</li>
<li>发现有可执行的微任务，所以执行process3和then3，分别输出10和12；</li>
</ul>
<p>OK，到了这里第三轮事件循环正式结束，输出结果为9、11、10、12。</p>
<p>综上，我们的事件循环经历了三轮执行完毕，输出结果为：1、7、6、8、2、4、3、5、9、11、10、12。</p>
<blockquote>
<h3 id="null和undefined有什么区别？"><a href="#null和undefined有什么区别？" class="headerlink" title="null和undefined有什么区别？"></a>null和undefined有什么区别？</h3></blockquote>
<p>null表示“没有对象”，即此处不应该有值。典型用法：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeof(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>undefined表示“缺少值”，就是本来这个地方应该有一个值，但是还没有定义。典型用法：</p>
<ul>
<li>变量被声明了，但是没有赋值，该变量等于undefined；</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined；</li>
<li>对象没有赋值的属性，其属性值为undefined；</li>
<li>函数没有返回值，默认返回undefined；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="built_in">console</span>.log(x)&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.p <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = f();</span><br><span class="line">x <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="typeof-和-instanceof-有什么区别"><a href="#typeof-和-instanceof-有什么区别" class="headerlink" title="typeof 和 instanceof 有什么区别"></a>typeof 和 instanceof 有什么区别</h3></blockquote>
<p>从判断类型来讲：</p>
<ul>
<li>typeof是用来判断基本数据类型的（number、boolean、string、function、object、undefined）</li>
<li>instanceof是用来判断对象的类型的，顾名知义，我们要判断的前提是我们判断的量是一个对象</li>
</ul>
<p>从运算符来讲：</p>
<ul>
<li>typeof是一元运算符</li>
<li>instanceof是二元运算符</li>
</ul>
<p>从返回结果来讲：</p>
<ul>
<li>typeof是求值，返回被求值的数据类型，返回值为一个字符串</li>
<li>instanceof是一个判断，返回一个布尔值，判断被运算的值是否是预期预算的类型</li>
</ul>
<p>从应用场景来讲：</p>
<ul>
<li>typeof可以用来判断一个变量是否已定义（根据返回是否是’undefined’）</li>
<li>instanceof主要用来判断对象之间的关系，尤其是自定义对象（比方说构造函数）</li>
</ul>
<p>一些特殊的情况：</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断一个变量是否是数组 使用instanceof</li>
<li></li>
</ul>
</li>
</ul>
<blockquote>
<h3 id="window、document、DOM、BOM-有什么区别"><a href="#window、document、DOM、BOM-有什么区别" class="headerlink" title="window、document、DOM、BOM 有什么区别"></a>window、document、DOM、BOM 有什么区别</h3></blockquote>
<ol>
<li><ul>
<li>DOM是 Document Object Model， 也就是文档对象模型</li>
<li>DOM就是一个API，有了它我们就可以轻易的去操作HTML的内容（比如元素的添加、修改、删除）</li>
</ul>
</li>
<li><ul>
<li>BOM是Browser Object Model，也就是浏览器对象模型</li>
<li>BOM也是一个API，而它就是为了操作浏览器的行为而诞生的（比如页面的跳转、前进、后退、获取屏幕大小等等）</li>
</ul>
</li>
<li><ul>
<li>document通常是一根DOM树的根节点</li>
<li>在一个浏览器窗口可能会有多个document，例如页面加载了多个iframe</li>
</ul>
</li>
<li><ul>
<li>window是BOM的一个对象</li>
</ul>
</li>
</ol>
<p>总结一下：</p>
<p><strong>DOM是为了操作文档而出现的API，document是其的一个对象</strong></p>
<p><strong>BOM是为了操作浏览器行为而出现的API，window是其的一个对象</strong></p>
<blockquote>
<h3 id="普通函数和箭头函数的区别"><a href="#普通函数和箭头函数的区别" class="headerlink" title="普通函数和箭头函数的区别"></a>普通函数和箭头函数的区别</h3></blockquote>
<p>首先我们先对箭头函数做一下基础的普及。</p>
<p>箭头函数（Arrow Function）是ES6新增的一种函数，其定义就是用一个箭头：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上面的箭头函数相当于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数就相当于是匿名函数，它简化了函数的定义。</p>
<p>箭头函数在只有一条表达式语句的时候可以省略花括号和return，如上面的例子。在包含多条表达式的情况下不能省略花括号和return：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数的参数在只有一个的情况下可以省略括号，在没有参数或者多个参数的情况下则不能省略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line">x =&gt; x * x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line">() =&gt; <span class="number">6.12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line">(x, y) =&gt; x * y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">	<span class="keyword">var</span> i,  sum = x + y;</span><br><span class="line">	<span class="keyword">for</span> (i &lt; rest.length; i++) &#123;</span><br><span class="line">		sum += rest[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要箭头函数返回一个对象需要这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = &gt; (</span><br><span class="line">	&#123;<span class="attr">foo</span>: x&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>好了，铺垫了这么多，我们开始说一下普通函数和箭头函数之间到底有什么区别：</p>
<ul>
<li><strong>this</strong></li>
</ul>
<p>在箭头函数中，内部的this是词法作用域，由上下文确定：</p>
<p>看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	birth: <span class="number">1992</span>,</span><br><span class="line">	getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> b = <span class="keyword">this</span>.birth  <span class="comment">// 1992</span></span><br><span class="line">		<span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth;  <span class="comment">// this指向window或undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fn();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们得不到预期的结果，但是在箭头函数中可以得以修复：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	birth: <span class="number">1992</span>,</span><br><span class="line">	getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> b = <span class="keyword">this</span>.birth  <span class="comment">// 1992</span></span><br><span class="line">		<span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth;  <span class="comment">// this指向window或undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> fn();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="什么是高阶函数？"><a href="#什么是高阶函数？" class="headerlink" title="什么是高阶函数？"></a>什么是高阶函数？</h3></blockquote>
<p>一个函数可以接受另一个函数作为参数，这种函数就可以称之为高阶函数。</p>
<p>简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="高阶函数应用、有什么意义？"><a href="#高阶函数应用、有什么意义？" class="headerlink" title="高阶函数应用、有什么意义？"></a>高阶函数应用、有什么意义？</h3></blockquote>
<ul>
<li>函数柯里化  // Todo</li>
<li>反柯里化  // Todo</li>
<li>函数节流  //  Todo</li>
<li>分时函数  // Todo</li>
<li>惰性加载  // Todo</li>
</ul>
<blockquote>
<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3></blockquote>
<p>首先看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">110</span>;     <span class="comment">// a为局部变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 110</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// a is not defined  外部访问不到内部的变量</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们想要在函数fn的外部访问到a却不得之，我们尝试利用作用域链去拿到a，对这个fn函数加以改造：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们若是执行fn()，然后去打印fn(),返回的是fn内部return的匿名函数，所以我们需要对这个匿名函数进行自执行，故fn()() 如此我们就在函数的外部访问到了内部的变量</span></span><br><span class="line">fn()(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样写</span></span><br><span class="line"><span class="keyword">var</span> fn2 = fn();</span><br><span class="line">fn2();</span><br></pre></td></tr></table></figure>
<p>结论：</p>
<p><strong>闭包是一个函数</strong></p>
<p><strong>闭包是一个能够读取其他函数内部变量的函数</strong></p>
<p>所以忘记闭包，我们现在所认识的就是 —— 一个函数可以打破之前我们不能在函数外部访问内部变量的格局，这个函数就是让初学者炸毛的闭包。</p>
<blockquote>
<h3 id="对原型的理解"><a href="#对原型的理解" class="headerlink" title="对原型的理解"></a>对原型的理解</h3></blockquote>
<p>Show  code:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建示例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>)</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br></pre></td></tr></table></figure>
<p>执行printName()很好理解，我们在 f 找个对象上面定义了这个方法；</p>
<p>但是执行alertName()的时候发生了什么？</p>
<p><strong>当试图得到一个对象的属性的时候，如果这个对象本身没有这个属性，那么会去该对象 f 的_ <em>proto</em> _（由于md语法问题，我们称之为<strong>杠杠proto杠杠</strong>），也就是它的构造函数Foo的prototype中去寻找，所以我们在执行f.alertName()的时候就会找到Foo.prototype.alertName。</strong></p>
<p>那么，我们如何去判断这个属性是不是对象本身的属性呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> f) &#123;</span><br><span class="line">	<span class="keyword">if</span> (f.hasOwnProperty(item)) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="对原型链的理解"><a href="#对原型链的理解" class="headerlink" title="对原型链的理解"></a>对原型链的理解</h3></blockquote>
<p>show code again: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建示例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>)</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br><span class="line">f.toString()</span><br></pre></td></tr></table></figure>
<p>f 本身没有toString()， 并且f._ <em>proto</em> _(即Foo.prototype)中也没有toString()。</p>
<p><strong>当试图得到一个对象的属性的时候，如果这个对象本身没有这个属性，那么会到他的_ <em>proto</em> _ 中（即它的构造函数的prototype）中寻找</strong></p>
<p>我们在f. _ <em>proto</em> _ 中没有找到toString()，那就继续去 f . _ <em>proto</em> _ ._ <em>proto</em> _ 中去寻找。因为 f . _ <em>proto</em> _ 就是一个普通的对象。</p>
<p>这样一直往上找就会形成一个链式的结构，叫做原型链。</p>
<p>如果找到最上层都没有找到那么就宣告失败，返回undefined。</p>
<p>原型链中的this对象一直指向触发了这个事件执行的对象。</p>
<blockquote>
<h3 id="对原型和原型链的总结"><a href="#对原型和原型链的总结" class="headerlink" title="对原型和原型链的总结"></a>对原型和原型链的总结</h3></blockquote>
<ul>
<li>所有的引用类型（数组、函数、对象），都具有对象特性，即可自由扩展属性</li>
<li>所有的引用类型（数组、函数、对象），都有一个_ <em>proto</em> _属性，属性值是一个普通的对象</li>
<li>所有函数都有一个prototype属性，属性值也是一个普通的对象</li>
<li>所有的引用类型（数组、函数、对象），_ <em>proto</em> _属性都指向它的构造函数的prototype属性</li>
</ul>
<p>代码解释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要点一：自由扩展属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = []; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要点二：__proto__</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要点三：函数有 prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="关于-this、call、apply、bind"><a href="#关于-this、call、apply、bind" class="headerlink" title="关于 this、call、apply、bind"></a>关于 this、call、apply、bind</h3></blockquote>
<p>参考自掘金一位小姐姐总结：<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">https://juejin.im/post/59bfe84351882531b730bac2</a></p>
<h4 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h4><p>在ES5中，this的指向坚持一个真理：</p>
<p><strong>this永远指向最后调用它的那个对象</strong></p>
<p>Code1:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);          <span class="comment">// windowsName</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);    <span class="comment">// inner: Window</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>因为 <strong>this永远指向最后调用它的那个对象</strong>，而a()是window调用的。</p>
<p>Code2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	name: <span class="string">"Cherry"</span>,</span><br><span class="line">	fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure>
<p>因为<strong>this永远指向最后调用它的那个对象</strong>，这里fn的调用是a对象，所以…</p>
<p>Code3：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">"Cherry"</span>,</span><br><span class="line">  fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure>
<p> 因为<strong>this永远指向最后调用它的那个对象</strong>，这里最后调用fn的是a对象，所以…</p>
<p>Code4:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	<span class="comment">// name: "Cherry",</span></span><br><span class="line">	fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// undefined</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure>
<p>因为<strong>this永远指向最后调用它的那个对象</strong>，这里最后调用fn的是a对象，而a对象中没有name这个属性，所以…</p>
<p>Code5：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name : <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// name: "Cherry",</span></span><br><span class="line">  fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>因为<strong>this永远指向最后调用它的那个对象</strong>，这里最后调用fn的是window对象，所以…</p>
<h4 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h4><ul>
<li>箭头函数</li>
<li>在函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li>
<li>new实例化一个对象</li>
</ul>
<p>先用一个例子来看问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()  <span class="comment">// this.func1 is not a function</span></span><br></pre></td></tr></table></figure>
<p>最后调用setTimeout的对象是window，但是在window中并没有func1这个函数，所以报错。</p>
<h4 id="使用箭头函数改造"><a href="#使用箭头函数改造" class="headerlink" title="使用箭头函数改造"></a>使用箭头函数改造</h4><p>箭头函数的this始终指向函数定义时的this，而非执行时。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure>
<h4 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _this.func1();</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure>
<h4 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h4><h5 id="使用apply"><a href="#使用apply" class="headerlink" title="使用apply"></a>使用apply</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;.apply(a), <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure>
<h5 id="使用call"><a href="#使用call" class="headerlink" title="使用call"></a>使用call</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;.call(a), <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure>
<h5 id="使用bind"><a href="#使用bind" class="headerlink" title="使用bind"></a>使用bind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;.bind(a)(), <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()</span><br></pre></td></tr></table></figure>
<h4 id="apply-call-bind三者的区别"><a href="#apply-call-bind三者的区别" class="headerlink" title="apply call bind三者的区别"></a>apply call bind三者的区别</h4><p>apply和call的区别在于传入参数的不同，apply接受一个包含多个参数的数组，call接受若干个参数列表</p>
<ul>
<li><p>apply</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.apply(a,[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>call</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.call(a,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>bind和apply、call的区别在于bind是创建了一个新的函数，需要手动去执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)()</span><br></pre></td></tr></table></figure>
<p>（未完待续……）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://aspirinlovehyn.top/2019/前端面试叨逼叨/" data-id="ck57xg3z4001g0lznmnh7r61v" class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/博客代码片段化妆教程-md/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            博客代码片段化妆教程.md
          
        </div>
      </a>
    
    
      <a href="/2019/学习TypeScript-基础篇-Part-4/" class="article-nav-link">
        <strong class="article-nav-caption">Older posts</strong>
        <div class="article-nav-title">学习TypeScript(基础篇)-Part.4</div>
      </a>
    
  </nav>


  

  

  
  
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'f295049de18d8401e996',
      clientSecret: '6c99e302ccc4eb0fc6775db22fc7bb3517c7f8aa',
      repo: 'AspirinMrmi.github.io',
      owner: 'AspirinMrMi',
      admin: ['AspirinMrMi'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2018-2020
        Aspirin
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src></script>
        
      </li>
    </ul>
  </div>
</footer>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/love.svg" alt="Aspirin&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/About-me/">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<script src="/js/ayer.js"></script>


  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  </div>
</body>

</html>